# -*- coding: utf-8 -*-
"""Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e_Jq7wxq1kg7kHqZQNiDM13jztwHfv9O
"""

# Celda para cargar librerias 
import os 
import math as m 
import random as rnd 
import time 
# Cargamos numpy 
import numpy as np

help(np)

# Creacion de objetos de tipo ndarray
a = np.array([12,16,9,23,32,0])

type(a)

dir(a)

# Documentacion del metodo sum
help(a.sum)

a.sum()

# Definamos un ndarray bidimensional
b = np.array([[1,4,7],[2,5,9]])

print(b)

b

b.sum()

# Sumamos los elementos sobre las columnas 
b.sum(axis = 0)

# Sumamos los elementos sobre las filas 
b.sum(axis = 1)

c = np.array([(0,1,0),(2,4,6),(1,1,1)])
print(c)

# Sumamos por columnas
c.sum(axis = 0)

# Veamos el comportamiento de la funcion linspace
help(np.linspace)

# 50 puntos de -pi a pi
x1 = np.linspace(-m.pi,m.pi, 50 , endpoint= True)

x1

len(x1)

# Funcion zeros
help(np.zeros)

y1 = np.zeros(shape = 50)
print(y1)

y2 = np.zeros(shape = (1,2))
print(y2)

# Objeto tridimensional
y3 = np.zeros(shape = (2,3,2))
print(y3)

np.ones(shape = (2,2))

# Submodulo random 
dir(np.random)

# Documentacion de la funcion random, del submodulo random, del modulo numpy
help(np.random.random)

np.random.random()

# Documentacion de la funcion triangular
help(np.random.triangular)

t1 = np.random.triangular(2.8, 3.23, 9.81, (3,3))
print(t1)

# Dado un objeto de tipo ndarray, tenemos a la mano algunos metodos informativos
print(t1.shape)
# Es una matriz de dimension 3x3

y1.shape

# Notar que el metodo shape retorna una tupla, y como  bien sabemos podemos acceder
# a los elementos de esa tupla
NumFilas = t1.shape[0]
NumColumnas = t1.shape[1]

y3.shape

# Numero de dimensiones del objeto 
y1.ndim

y3.ndim

# Tipo de dato de cada elemento de un objeto de tipo ndarray
t1.dtype

# Definamos un vector con componentes bool
b1 = np.array([True, True, False, False, True, True ])
print(b1)

b1.shape

b1.ndim

b1.dtype

# acceso a las componentes de un objeto de tipo ndarray
c[0,0]

c[0, 2]

# la 2da columna 
c[:,1]

c

# la 3era columna 
c[:,2]

# CReemos un objeto de tipo ndarray de tamaño 6x6
D = np.random.chisquare(12.4, (6,6))

D

# Deseo obtener las columnas 2,3 y 4
E = D[:, [2,3,4]]

# Funciones de agregacion
D.sum(axis = 0)

# Calcular la suma de las filas de E
E.sum(axis = 1)

# Calculemos la suma de las de columnas de E
E.sum(axis = 0)

# Calculo del promedio aritmetido : metodo mean
help(E.mean)

# Retorna el promedio para cada fila 
E.mean(axis = 1)

# Calculo del promedio para cada columna 
E.mean(axis = 0)

help(E.min)

help(E.max)

# Desviacion estandar
help(E.std)

# Desviacion estandar de cada columna 
E.std(axis = 0)

# Desviacion estandar para cada fila 
E.std(axis = 1)

E[E > 9.3]

Q = np.random.normal(loc = 12.4, scale = 9.2, size = (4,4))
P = np.random.normal(loc = 12.4, scale = 9.2, size = (4,4))
print(P)
print(Q)

# Operacion elemento a elemento
# R[i,j] = P[i,j] + Q[i,j]

R = P + Q

# Operacion elemento a elemento
# T[i,j] = P[i,j] - Q[i,j]


T = P - Q
print(T)

# Operacion elemento a elemento
# Prod[i,j] = P[i,j] * Q[i,j]


Prod = P*Q

# Multiplicacion matricial
help(np.multiply)

# multiplicacion matricial de P  y Q
M1 = np.multiply(P,Q)
print(M1)

# Submodulo de algebra lineal
help(np.linalg)

# lista de funciones del submodulo de algebra lineal 
dir(np.linalg)

# Documentacion de la funcion inv
help(np.linalg.inv)

# Documentacion de la funcion pinv
help(np.linalg.pinv)

# Generemos matrices de tamño/dimension 100000x100000 
# Calculemos sus inversas : usando inv y pinv 
# Y midamos los tiempos de unas 500 veces

n = 500
NumVeces = 500

NumCorrectas1 = 0
INICIO1 = time.time()
for v in range(500):
  A = np.random.triangular(1.3, 3.8, 12.9, (n,n))
  B = np.linalg.inv(A)
  Id = np.dot(A,B)
  V = np.identity(n) == Id
  if V.sum() == n*n:
    NumCorrectas1 = NumCorrectas1 +1
FIN1 = time.time()


NumCorrectas2 = 0
INICIO2 = time.time()
for v in range(NumVeces):
  A = np.random.triangular(1.3, 3.8, 12.9, (n,n))
  B = np.linalg.pinv(A)
  Id = np.dot(A,B)
  V = np.identity(n) == Id
  if V.sum() == n*n:
    NumCorrectas2 = NumCorrectas2 +1 
FIN2 = time.time()

print("Tiempo usando : inv " , FIN1-INICIO1)
print("Tiempo usando : pinv", FIN2-INICIO2)
print("El numero de correctas para inv es " ,NumCorrectas1)
print("El numero de correctas para pinv es " , NumCorrectas2)